# subversion读书笔记

- pubdate: 2008-12-16

--------------------------

读的这本书[《版本控制之道》](http://www.douban.com/subject/2038779/)

很多新人（比如说我）刚开始做项目的时候并没有什么规划，尤其是单枪匹马的时候。虽然也知道要备份代码，就是把项目复制一份存在硬盘的其他角落，标个日 期，等回想起来已经忘了每一份代码之间的区别。团队的话更是混乱，不可能把模块和模块分的很清楚，很容易造成冲突，所以版本控制是不可少的。

## 什么是subversion

版本控制就像一根时间轴，按时间顺序版本号慢慢增大，你可以回头看看以前各个版本到底做了什么，也可以对某个版本进行修改。如果发现现在的路都不同，可以从 以前某个版本走另外一条路，就像本书中Mike所说的平行世界，当然你也可以从这个平行世界回来，把两个版本重新合并。其实这还不够奇妙，这只是记录了我 以前做过什么，对于团队还有一个重要的定义——让人惶恐不安的加锁策略。

## 必须要知道的名词

在这之前必须知道一些名词，**项目仓库（repository）**可以设想出一个存放你文件的仓库，他可以是本地硬盘，可以是局域网的其他电脑，也可以是网络的任何一个节点。编辑完你的文件后最终是要提交到项目仓库的。**工作拷贝（working copy）**是相对于项目仓库来说的，当你将一部分文件从项目仓库拿到某个地方的时候，那个地方就是你的工作拷贝。我们在建立工作拷贝，第一次从项目仓库拷贝文件的操作叫做**签出（checkout）**。签出的工作拷贝都是项目最新的版本。在工作拷贝修改文件后要**提交（commit）**到项目仓库，版本库会增加版本号。有时在你修改的过程中由于其他人的提交使得版本号增加很多，所以你必须**更新（update）**工作拷贝到最近版本。不然就会造成**冲突（conflict）**，这也是使人惶恐不安的地方。

## subversion的版本号

subversion的版本号有所不同，是**项目仓库集体编号**。只要有人提交到项目仓库 ，版本号就会加1，而不是改变单个文件的版本号，没有修改过的文件也会随着一起提升编号。而**具体文件编号**则是对应于单个文件的编号，单个文件的修改提交后，其他文件的版本也不会改变，这种方式用来记录某个文件变动了多少。其实subversion也可以浏览单个文件的历史，用svn log或者svn blame。

## 加锁策略

为什么要加锁，其实这个锁在很多地方都碰到过，多人编辑同一个文件的时候总是会遇到冲突，但最后采用谁的呢，人都不知道电脑怎么知道，所以要加个锁。一般来说有两种策略，**严格加锁**，当一个人有编辑权限的时候，其他人是无法再去编辑的，只能等提交后其他人才能获取这个编辑权限。夸张一点，如果一个人在编辑一个文件的时候忘记提交然后出去旅游了，那么这段时间整个项目就无法进展了。subversion采用的是**乐观加锁**，其实就根本没加锁，每个人都可以编辑文件。但当然不能随意编辑，每个人只能编辑自己签出的本地拷贝，编辑完后再提交到项目仓库。这就是使人们恐慌的地方，如果两个人同时提交同一个文件那怎么办？但subversion已经解决了这个问题，在本地拷贝编辑好后提交到项目仓库时，本地拷贝的版本必须是最新的。如果其他人已经提交过使得项目仓库的版本号增加了，必须先更新本地拷贝的版本再提交。

## 状态符

在对文件进行操作后都会有相应的标识符来表示文件的状态。
    
    A 项目仓库中新添加的文件，更新到工作拷贝
    U 工作拷贝中的文件已经过期，从项目仓库中更新最新的版本到工作拷贝
    D 项目仓库中已经删除了这个文件，工作拷贝会删除这个文件
    G 工作拷贝中的文件已经过期，而且本地还做了修改，subversion成功合并项目仓库和工作拷贝的文件
    C 工作拷贝中的文件已经过期，而且本地还做了修改，但更新的时候产生冲突
    M 文件被修改过
    
## 如何解决冲突

这应该是使用版本控制的开发者最关心的问题，但这不只是版本控制的问题，还是整个项目管理的问题。使用这种开发方式，开发者们必须有很好的沟通交流，这是解 决冲突的唯一方法，subversion不是AI，他只能找出先后版本的差异，并不能解决两个开发者想法的差异。遇到冲突时不用着急，先找出和你想法有冲 突的那个人，找他谈谈找出一个好的解决方案，再回来解决冲突，最后提交两人都满意的结果。

## 查找差异

subversion拥有多个版本标识符，可以比较文件任意版本之间的差异。可以将版本号看成一条时间线，BASE就是刚签出或者更新的版本号，HEAD则是项目仓库中最新的版本号，COMMITTED是最后改动的版本，PREV则是COMMITTED之前的一个版本。

    svn diff #对比刚签出和修改过的版本
    svn diff -r HEAD #对比本地拷贝和项目仓库的最新版本
    svn diff -r PREV:BASE #对比刚签出的本地拷贝和之前一个版本也可以比较两个指定版本，
    svn diff -r19:21 #对比19和21两个版本，diff后可以输出一个补丁文件，然后用patch将这个补丁打进去。

## 属性和标签

**属性**是一些与文件关联的元数据，用来描述这个文件，java源代码可以有一个“审阅者”的属性，告诉你谁最后审阅过这个文件。属性同样可以版本化，与 subversion的其他文件一样，也会发生冲突。subversion定义了很多svn:开头的属性，可以改变处理文件的行为。

**标签**其实也算一个分支，但只记录一个时间点，可能是某一个发布版，也可以是一个bug修订的起始点。

## 分支和合并

分支虽然方便，但不是运用的越多越好，就像Mike说的很多团队已经拒绝使用分支。他建议我们四种用法：

### 发布分支

在项目的开发过程中，有时需要发布一个版本，但一些新添加的功能并不包含在这个发布版本中，而且不能耽误项目时间，需要继续开发。所以将一个要发布的版本作为一个分支继续完善，以待发布。

### 发布

当在一个发布分支中觉得可以发布了，那么将分支复制到一个标签目录下，确定一个标签名（比如rb1.0.0或rb1.0.0-fixed）。

### 在发布分支中修正bug

bug是随时都有的，但分支上存在的bug，一般在主干上也存在，所以必须把修正的bug应用到主干上。简单的bug只需对比修正bug前后的版本然后应用到主干。复杂一点的则需要建立一个bug的分支，设定起始和终止的标签，然后将标签之前的差异应用到主干。


### 开发人员试验

建立分支供开发者试验用，如有成果可合并到主干。

建立分支和标签其实没有想象那么复杂，只是将文件全部复制过去。一般项目的目录结构为proj/trunk,proj/branch,proj/tag,trunk为主干，branch为分支，tag为标签。**合并**其实并不是字面上意思，其实是先diff一下前后（版本号，标签）两个版本，将他们的差别应用到工作拷贝上，所以最后需要提交才能改变项目仓库中的数据。

## 参考命令

```
svn import path URL #将指定路径的文件目录导入项目仓库中
svn checkout URL path #从项目仓库中签出，如果没有指定path，本地目录名使用URL的base name
svn update #更新工作拷贝到最新版本
svn add path #添加文件到项目仓库，还需提交
svn diff path #比较文件差异
svn diff > patchfile -> patch -p0 -i patchfile #比较文件差异后输出补丁，再将补丁打上
svn revert file #废弃所做的改动
cp file.mine file -> svn resolved file #遇到冲突时，废弃别人的改动
svn commit -m "message" #提交，加上备注
svn log (-v) file #查看文件的历史（指定版本）
svn blame file #查看文件每行修改的版本号和作者名
svn merge -r rev:rev-1 path #撤销一个已经提交的改动，就是回滚
svn status (--show-updates) #检查工作拷贝的状态(项目仓库中的状态)
svn switch URL #切换不同的项目仓库到同一个工作拷贝
svn copy src dest #将一个目录复制到另一个目录
```
